% Yay, the article for the end of this year, in LaTeX.

\documentclass[a4paper, 12pt]{article}

\newcommand{\ffi}{\Leftrightarrow}
\newcommand{\imply}{\Rightarrow}


\usepackage[french]{babel}
\usepackage{listings}
\usepackage{fancyhdr, fancybox}
\usepackage{amsmath, amssymb}
\usepackage{xcolor, changepage, array, placeins, float, verbatim}
\usepackage{qtree, forest}
\usepackage[utf8]{inputenc}
\usepackage{listingsutf8}
\pagestyle{fancy}

\definecolor{codecomments}{HTML}{FFA700}
\definecolor{codenumbers}{HTML}{D62D20}
\definecolor{codestrings}{HTML}{008744}
% \definecolor{backcolour}{HTML}{F7F7F7}
\definecolor{keycolor}{HTML}{3B5998}%{0057E7}
\definecolor{backcolour}{HTML}{FFFFFF}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codecomments},
    keywordstyle=\color{keycolor},
    numberstyle=\tiny\color{codenumbers},
    stringstyle=\color{codestrings},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbersep=5pt,
    showspaces=false,
    xleftmargin=\parindent,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    rulecolor=\color{black},
    frame=L
  }

\lstset{
    style=mystyle,
    morecomment=[s][\color{codenumbers}]{@}{\ },
    extendedchars=true,
    literate={Ã©}{{\'e}}1
    {Ã¢}{{\^a}}1
    {Ã }{{\`a}}1
    {Ãª}{{\^e}}1
    {Ã¨}{{\`e}}1
    {Ã®}{{\^i}}1
    {0}{{{\color{codenumbers}0}}}1
    {1}{{{\color{codenumbers}1}}}1
    {2}{{{\color{codenumbers}2}}}1
    {3}{{{\color{codenumbers}3}}}1
    {4}{{{\color{codenumbers}4}}}1
    {5}{{{\color{codenumbers}5}}}1
    {6}{{{\color{codenumbers}6}}}1
    {7}{{{\color{codenumbers}7}}}1
    {8}{{{\color{codenumbers}8}}}1
    {9}{{{\color{codenumbers}9}}}1
    {1-}{{{\color{codenumbers}1-}}}2
    {1+}{{{\color{codenumbers}1+}}}2
    {remove-if}{{{\color{keycolor}remove-if}}}8
    {if}{{{\color{keycolor}if}}}2
    {True}{{{\color{teal}True}}}4
    {False}{{{\color{teal}False}}}4
    {await}{{{\color{keycolor}await}}}5
    {\ as\ }{{{\color{keycolor}as}}}4
    {async\ }{{{\color{keycolor}async}}}5
  }
\renewcommand{\theequation}{\thesection.\arabic{equation}}
\renewcommand{\sectionmark}[ 1 ]{\markboth{\thesection. #1 }{ }}
\renewcommand{\subsectionmark}[ 1 ]{\markright{\thesubsection. #1 }}

\renewcommand{\labelenumi}{\alph{enumi}.}
\renewcommand{\theenumi}{\alph{enumi}.}
\renewcommand{\labelenumii}{\roman{enumii}.}
\renewcommand{\theenumii}{\roman{enumii}.}

\rhead[\textbf{}]{\textbf{}}
\lhead[\textbf{}]{\textbf{}}
\lfoot[{\bf \thepage}]{{\bf \thepage}}
\rfoot[{\bf \thepage}]{\textbf{IA PAS DE SOUCIS!}}
\cfoot[]{}

\numberwithin{equation}{subsection}
\renewcommand{\headrulewidth}{ 0.15 mm}
\renewcommand{\footrulewidth}{ 0.15 mm}
\addtolength{\headwidth}{\marginparsep}
\addtolength{\headwidth}{\marginparwidth}

\newcolumntype{M}[ 1 ]{>{\centering\arraybackslash}m{#1}}

\title{IA Pas de Soucis!}
\author{Avec une assistance minimale de Evrard Maurice,\\ Lejeune GrÃ©gory,\\ Mathieu Louca,\\ Pluvinage Victor\\ et de Ralet Vincent.}

\begin{document}
\begin{center}
  {\Huge {\bf Un projet de LEJEUNE Lucas}}
\end{center}
\maketitle
\newpage

\section{Histoire.}
\subsection{Origines.}
\begin{enumerate}
  \item 1949 dans une publication de Warren Weaver\footnote{Warren Weaver, mathÃ©maticien amÃ©ricain, considÃ©rÃ© comme la 1Ã¨re personne Ã  proposer lâ€™utilisation dâ€™ordinateur Ã©lectronique pour la traduction grÃ¢ce Ã  des techniques statistiques} par rapport Ã  la traduction automatique des langues.
  \item 1950 dans un article dâ€™Alan Turing\footnote{Alan Turing: Histoire dit de lui quâ€™il a dechiffrer un code secret des machines Enigma utilisÃ© par les allemands Ã  lâ€™aide Bletchley Park(un chÃ¢teau rempli de mathÃ©maticien) qui aurait permis de raccourcir la seconde guerre mondiale de 2 ans} qui dÃ©finit si une machine est consciente ou non.
\end{enumerate}
\subsection{Officialisation de lâ€™IA comme vÃ©ritable domaine scientifique.}
\begin{enumerate}
  \item 1956 lors dâ€™une confÃ©rence aux USA qui permettra Ã  celle-ci dâ€™atteindre des universitÃ© prestigieuse comme stanford, etc
\end{enumerate}
\subsection{Suite de l'IA.}
\begin{enumerate}
  \item 1974 arrive le â€œAl Winterâ€. RÃ©duction du budget des acadÃ©mies car elles ne font pas aboutir leur projet sur quelque chose de concret
  \item AnnÃ©e 80, Gouvernements financent de nouveau les acadÃ©mies car IA atteint une valeur dâ€™un milliard de dollars, a ce moment, un systÃ¨me expert Ã©tait un ordinateur capable de se comporter comme un humain (dans un domaine prÃ©cis)
  \item la loi de Moore (Ã©volution de la puissance de calcul des ordinateurs ainsi que de leurs complexitÃ©s), entre 1990 et 2000, On trouve le data mining (composante des technologies)
  \item 1997: Deep blue (superintelligence spÃ©cialisÃ© dans le jeu dâ€™Ã©checs)
\end{enumerate}
\section{L'approche logique.}
\subsection{Les bases de la logique}
  \subsubsection{Introduction Ã  la logique propositionnelle.}
     L'importance de la logique propositionnelle est immense en mathÃ©matiques et en cryptographie, mais Ã©galement, comme nous allons le voir, en informatique.\\
     Voici une fameuse lapalissade, exemple typique d'utilisation d'une phrase ne dÃ©coulant de rien d'autre que de cette logique:
  \begin{center}
    \shadowbox{{\bf ''15 minutes avant sa mort, il Ã©tait encore en vie.''}\footnotemark} \footnotetext{ https://fr.wikipedia.org/wiki/Lapalissade}
  \end{center}
     Ã‰videmment, grÃ¢ce Ã  notre capacitÃ© dÃ©ductionnelle, nous pouvons tous dÃ©finir cette phrase comme vraie, c'est ici, une vÃ©ritÃ© dite ``de  langage''. \\[0.5cm]

  \subsubsection{Un peu de vocabulaire!}
     La logique propositionnelle possÃ¨de son propre vocabulaire, il est presque indispensable de connaÃ®tre son vocabulaire et sa syntaxe afin mÃªme de  pouvoir en comprendre les concepts.\\
     Tout d'abord, un {\bf langage formel} est un ensemble de mots que l'on peut obtenir en utilisant un alphabet\footnote{Cela peut Ãªtre un alphabet comme abcd...yz tout comme un alphabet composÃ© uniquement de 1 et de 0.}, un langage possÃ¨de plusieurs {\bf lois}, cet ensemble de lois sera appelÃ© la {\bf syntaxe}, qui dÃ©finissent les diffÃ©rentes maniÃ¨res grÃ¢ce auxquelles les Ã©lÃ©ments de l'alphabet (aussi appelÃ©s  les {\bf symboles}) peuvent se placer pour former quelque chose de cohÃ©rent au langage.\\ Par exemple, en franÃ§ais, vous n'Ã©cririez pas ``JÃ¨me lai vwaturres'', mais plutÃ´t, ``j'aime les voitures'', aussi bÃªte que ce petit exemple puisse paraÃ®tre, il s'agit  lÃ  de l'une des nombreuses fois oÃ¹ l'on se plie aux rÃ¨gles d'une grammaire logique. \\
     Un mot respectant toutes les rÃ¨gles de syntaxe sera alors appelÃ© un {\bf mot bien-formÃ©}. \\
     {\bf La logique propositionnelle} se compose donc d'un langage formel, et de sÃ©mantiques donnant du sens aux mots bien formÃ©s, rÃ©pondant au nom de {\bf propositions}. \\
     Les propositions logiques sont dÃ©signÃ©es par des lettres, comme $ A, B, C$..., ou par des lettres indicÃ©es comme $ A_2, B_{4}$...
     Pour relier ces propositions, on utilise des connecteurs, rÃ©pertoriÃ©s dans le tableau ci-dessous. \\
     \begin{table}[!t]
       \centering
       \begin{tabular}{|c|c|c|}
         %!{\vrule width 0.8mm}>{\bfseries}l|
         %>{$}<{$}!{\vrule width 0.8mm}}
         \hline {\bf nom }       & {\bf symbole}     & {\bf autre nom}  \\
         \hline nÃ©gation         & $\neg$            & NOT              \\
         conjonction             & $\land$           & AND              \\
         disjonction (I)         & $\lor$            & OR               \\
         disjonction (E)         & $\oplus$          & XOR              \\
         implication             & $\imply$          & IF..THEN         \\
         Ã©quivalence             & $\ffi$            & IFF              \\
         \hline
       \end{tabular}
    \end{table}
  En plus de ces connecteurs viennent s'ajouter les deux valeurs logiques Ã  la base de tout, Vrai et Faux.
    \subsubsection{Pour quelques exemples de plus...}
        Voici quelques exemples d'Ã©noncÃ©s de logique propositionnelle dans un cadre assez Ã©loignÃ© des mathÃ©matiques, en espÃ©rant que cela fasse sens au lecteur.\\
        Supposons que $A$ et $B$ soient deux propositions logiques. \\
        $A$: Je suis boulanger. \\
        $B$: Je sais faire des gÃ¢teaux. \\
        Nous pouvons ainsi relier ces deux propositions avec les connecteurs vus dans le tableau ci-dessus. \\
        $\neg A$: Je ne suis pas boulanger. \\
        $\neg B$: Je ne sais pas faire des gÃ¢teaux. \\
        $A \land B$: Je suis boulanger et je sais faire des gÃ¢teaux. \\
        $A \lor B$: Je suis boulanger ou je sais faire des gÃ¢teaux (Les deux propositions peuvent Ãªtre vraies, tout comme une seule des deux). \\
        $A \oplus B$: Je suis boulanger ou alors je sais faire des gÃ¢teaux. (Une seule de ces deux propositions doit Ãªtre vraie) \\
        $A \imply B$: Je suis boulanger, donc je sais faire des gÃ¢teaux. \\
        $A \ffi B$: Je suis boulanger si et seulement si je sais faire des gÃ¢teaux. \\
        ... \\
    \subsubsection{Quelques tables de vÃ©ritÃ©.}
    AprÃ¨s tant d'exemples ``instructifs'', il serait temps de passer aux fameuses {\bf tables de vÃ©ritÃ©}, ces tables seront d'une importance capitale lors de rÃ©solutions de problÃ¨mes, les voici donc: \\[15.0cm]
    \begin{table}[!t]
      \hspace{1.0cm}
      \begin{minipage}[c]{0.1\linewidth}
        \centering
        \caption{NÃ©gation.}
        \label{neg_table}
      \begin{tabular}{|c|c|}
        \hline $A$ & $\neg A$ \\
        \hline  F  &     V    \\
                V  &     F    \\
        \hline
      \end{tabular}
    \end{minipage}
    \hspace{2.0cm}
    \begin{minipage}[c]{0.22\linewidth}
      \centering
      \caption{\\Conjonction.}
      \label{and_table}
      \begin{tabular}{|c|c|c|}
        \hline $A$ & $B$ & $A \land B$ \\
        \hline  F  &  F  &      F      \\
                F  &  V  &      F      \\
                V  &  F  &      F      \\
                V  &  V  &      V      \\
        \hline
      \end{tabular}
    \end{minipage}
    \hspace{1.0cm}
    \begin{minipage}[c]{0.27\linewidth}
      \centering
      \caption{\\Disjonction (OR).}
      \label{or_table}
    \begin{tabular}{|c|c|c|}
        \hline $A$ & $B$ & $A \lor B$  \\
        \hline  F  &  F  &      F      \\
                F  &  V  &      V      \\
                V  &  F  &      V      \\
                V  &  V  &      V      \\
        \hline
    \end{tabular}
  \end{minipage}
  \\[1.0cm]
  \begin{minipage}[c]{0.27\linewidth}
    \centering
    \caption{\\Disjonction (XOR).}
    \label{xor_table}
      \begin{tabular}{|c|c|c|}
        \hline $A$ & $B$ & $A \oplus B$ \\
        \hline  F  &  F  &       F      \\
                F  &  V  &       V      \\
                V  &  F  &       V      \\
                V  &  V  &       F      \\
        \hline
      \end{tabular}
    \end{minipage}
    \hspace{1.0cm}
    \begin{minipage}[c]{0.22\linewidth}
      \centering
      \caption{\\Implication.}
      \label{imply_table}
      \begin{tabular}{|c|c|c|}
        \hline $A$ & $B$ & $A \imply B$ \\
        \hline  F  &  F  &       V        \\
                F  &  V  &       V        \\
                V  &  F  &       F        \\
                V  &  V  &       V        \\
        \hline
      \end{tabular}
    \end{minipage}
    \hspace{1.0cm}
    \begin{minipage}[c]{0.1\linewidth}
      \centering
      \caption{Ã‰quivalence}
      \label{iff_table}
      \begin{tabular}{|c|c|c|}
        \hline $A$ & $B$ & $A \ffi B$ \\
        \hline  F  &  F  &      V     \\
                F  &  V  &      F     \\
                V  &  F  &      F     \\
                V  &  V  &      V     \\
        \hline
      \end{tabular}
    \end{minipage}
  \end{table}
  Les tables 1 Ã  4 doivent sans doute paraÃ®tre logique, je m'attarderai toutefois sur la table 5, en effet les deux phrases $F \imply V$ et $F \imply F$ sont toutes deux vraies.
  Cela est du au {\bf principe d'explosion}\footnote{https://fr.wikipedia.org/wiki/Principe\_d$\%$27explosion}: Du faux, on peut dÃ©duire absolument n'importe quoi! (On verra plus tard que l'on peut noter ceci $A \land \neg A \models B$).\\
  Pour ce qui est de la table 6, il faut savoir que certains notent $\ffi$ comme Ã©tant $\equiv$, cette notation a l'avantage d'accentuer le fait que cette relation n'est autre que la relation d'Ã©quivalence.
  \subsubsection{RÃ©solution de problÃ¨mes en logique propositionnelle.}
  Maintenant que nous avons acquis les bases de la logique propositionnelle,  attaquons nous Ã  quelques problÃ¨mes.\\
  En voici un premier,
  \begin{center}
    \Ovalbox{$ \neg (A \land B ) \ffi \neg A \lor \neg B$}
  \end{center}
  Pour rÃ©soudre ceci, nous allons utiliser une grande table de vÃ©ritÃ©: \newpage
  \begin{table}[!t]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
      \hline $A$ & $B$ & $A \land B$ & $\neg (A \land B)$ & $\neg A$ & $\neg B$ & $\neg A \lor \neg B$ & $\neg (A \land B) \ffi \neg A \lor \neg B$ \\
      \hline  F  &  F  &      F      &          V         &     V    &     V    &          V           &                     V                      \\
              F  &  V  &      F      &          V         &     V    &     F    &          V           &                     V                      \\
              V  &  F  &      F      &          V         &     F    &     V    &          V           &                     V                      \\
              V  &  V  &      V      &          F         &     F    &     F    &          F           &                     V                      \\
      \hline
    \end{tabular}
  \end{table}
  Ainsi, comme nous pouvons le constater, la derniÃ¨re ligne est remplie de ``V'', cela veut donc dire que nous venons de prouver la relation $\neg (A \land B) \ffi \neg A \lor \neg B$ , aussi connue sous le nom de ``la loi de DeMorgan'', nous avons prouvÃ© par la mÃªme occasion que $\neg (A \land B) \ffi \neg A \lor B$ est {\bf valide}, cela veut dire qu'elle sera toujours vraie, peu-importe les A, et les B.\\[0.5cm]
  Il existe toutefois une autre maniÃ¨re de faire, il s'agit d'utiliser un arbre, cette mÃ©thode requiert moins d'Ã©tapes et nous permettra de rÃ©soudre certains problÃ¨mes de maniÃ¨re plus simple. Toutefois, il y a quelques rÃ¨gles Ã  respecter lors de l'utilisation d'un arbre, ces  rÃ¨gles sont rÃ©pertoriÃ©es dans le tableau ci-dessous. \\
  \begin{center}
    \begin{table}[!hbt]
      \centering
    \begin{tabular}{|M{2.5cm}|M{2.5cm}|M{2.5cm}|}
      \hline \begin{forest} [$\neg (\neg \phi)$ [$\phi$]]\end{forest} & \begin{forest} [$\phi \land \psi$ [$\phi$ [$\psi$]]] \end{forest} & \begin{forest} [$\neg (\psi \land \phi)$ [$\neg \psi$] [$\neg \phi$]] \end{forest} \\
     \hline \begin{forest} [$\phi \lor \psi$ [$\phi$][$\psi$]] \end{forest}& \begin{forest} [$\neg (\phi \lor \psi)$ [$\neg \phi$ [$\neg \phi$]]] \end{forest}  & \begin{forest} [$\phi \imply \psi$ [$\neg \phi$][$\psi$]] \end{forest}\\
      \hline \begin{forest} [$\neg (\phi \imply \psi)$ [$\phi$ [$\neg \psi$]]] \end{forest}& \begin{forest} [$\phi \ffi \psi$ [$\phi$ [$\psi$]] [$\neg \phi$ [$\neg \psi$]]] \end{forest}& \begin{forest} [$\neg (\phi \imply \psi)$ [$\phi$ [$\neg \psi$]] [$\neg \phi$ [$\psi$]]]\end{forest} \\
      \hline
    \end{tabular}
  \end{table}
  \end{center}
  Le but du jeu avec un arbre logique, c'est de terminer chacune des branches de l'arbre par $\bot$ (C'est le symbole utilisÃ© pour les contradictions). Ainsi, avec un arbre, nous commenÃ§ons par utiliser l'opposÃ© de notre hypothÃ¨se de base (ici, l'opposÃ© de $\neg (A \land B) \ffi \neg A \lor \neg B$, c'est $\neg (\neg (A \land B) \ffi \neg A \lor \neg B)$), (en gÃ©nÃ©ral, une contradiction arrive quand nous nous retrouvons avec $A$ et $\neg A$ sur la mÃªme branche.) \\
  Passons maintenant Ã  la preuve
  \begin{center}
  \begin{forest}
  [$\neg (\neg (A \land B) \ffi \neg A \lor \neg B)$
    [$\neg(A \land B)$
    [$\neg (\neg A \lor \neg B)$
    [$A$
    [$B$
    [$\neg A$
    [$\bot$]]
    [$\neg B$
    [$\bot$]]]]]]
    [$\neg (\neg (A \land B))$
    [$ \neg A \lor \neg B$
    [$A \land B$
    [$A$
    [$B$
    [$\neg A$
    [$\bot$]]
    [$\neg B$
    [$\bot$]]]]]]]]
  \end{forest}
\end{center}
Chaque branche de l'arbre fini bien par $\bot$, nous venons donc de prouver la loi de DeMorgan, avec l'aide de notre arbre de dÃ©monstration. \\[1.0cm]
    Ci dessous, le lecteur pourra s'essayer Ã  la dÃ©monstrations de certaines lois logiques cÃ©lÃ¨bres, avec l'aide d'un tableau ou avec un arbre. \\[1.0cm]
  \begin{equation}\neg \neg A \ffi A \end{equation}
  \begin{equation} A \land \neg A \ffi F \end{equation}
  \begin{equation} A \lor \neg A \ffi T \end{equation}
  \begin{equation} A \land F \ffi F \end{equation}
  \begin{equation} A \lor V \ffi V \end{equation}
  \begin{equation}
    \begin{cases}
      A \lor B \ffi B \lor A \\
      A \land B \ffi B \land A
    \end{cases}
  \end{equation}
  \begin{equation}
    \begin{cases}
      A \land (B \land C) \ffi (A \land B) \land C \\
      A \lor (B \lor C) \ffi (A \lor B) \lor C
    \end{cases}
  \end{equation}
  \begin{equation}A \land (B \lor C) \ffi (A \land B) \lor (A \land C) \end{equation}
  \subsection{Les ensembles de propositions.}
  Les ensembles de propositions, comme leur nom l'indique, sont des ensembles mathÃ©matiques, composÃ©s de {\bf formules logiques}.
  Ces formules sont dites soit: \\
  \begin{itemize}
  \item {\bf consistantes}, signifiant qu'il est possible d'en tirer du Vrai, par exemple $A \land B$ ou encore $\neg \neg A \imply A$.
  \item {\bf inconsistances}, signifiant que l'on ne peut en tirer que du Faux, par exemple $A \land \neg A$, ces formules peuvent Ãªtre notÃ©es $\bot$.
  \item {\bf valides}, signifiant qu'elles ne peuvent Ãªtre que Vraies, comme $A \lor \neg A$ (principe du tiers-exclus), une formule {\bf valide} est par dÃ©finition toujours {\bf consistante}, on appelle bien souvent ces formules valides des {\bf tautologies}, ces formules pourront Ãªtre notÃ©es $\top$. \\
  \item {\bf contingentes}, impliquant que l'on peut tirer de la formule du faux, tout comme du vrai, une {\bf tautologie} ne peut pas Ãªtre formule contingente,
  un exemple de formule contingente serait $A \lor B$.
  \end{itemize}

  Les ensembles aussi ont leur propre terminologie, ainsi, si l'on prend l'ensemble notÃ© $S$, il pourra Ãªtre qualifiÃ© Ã©galement de {\bf consistant}, si il n'y a pas de contradictions au sein de $S$ et qu'il n'y a aucune formule inconsistante contenue dans $S$, autrement $S$ sera dÃ©fini comme Ã©tant {\bf inconsistant}. \\[0.5cm]
  Il y a plusieurs maniÃ¨res d'{\bf infÃ©rer} quelque chose d'un ensemble logique. \\
  Une premiÃ¨re maniÃ¨re est de prendre les {\bf prÃ©misses} qui nous intÃ©ressent, et d'Ã©crire \\[0.5cm]
    1. {\bf Premisse\_A} \\
    2. {\bf Premisse\_B} \\
    \hspace{0.2cm}$\vdots$ \\
    n. {\bf Premisse\_X} \\
    \hspace{0.5cm}\line(1, 0){60} \\
    $\therefore$ {\bf Conclusion} \\[0.5cm]
  Prenons un ensemble {\bf consistant} $S$ composÃ© des formules $A$ et $A \imply B$. \\
  On pourrait alors noter $S$ comme Ã©tant $S = \{ A, A \imply B \}$ (ce qui est parfaitement Ã©quivalent Ã  Ã©crire $S = A \land (A \imply B)$), \\
  De ceci, nous allons utiliser l'opÃ©rateur de la dÃ©duction, $\vDash$, ceci nous permettra ainsi Ã©crire $S \vDash A$, littÃ©ralement ``De $S$, nous dÃ©duisons $A$''. \\Ce principe est encore plus flagrant quand nous utilisons la notation suivante : $A, A \imply B \models A$, oÃ¹ $A, A \imply B$ n'est autre que l'ensemble S, avec une notation lÃ©gÃ¨rement diffÃ©rente. \\[0.5cm]

  Je n'ai pas choisi cet ensemble de maniÃ¨re anodine, car, grÃ¢ce Ã  celui-ci, nous allons pouvoir utiliser une {\bf rÃ¨gle d'infÃ©rence} connue sous le nom du MP (Modus Ponens), le lecteur ne devrait toutefois pas s'inquiÃ©ter, un tableau recensant d'autres rÃ¨gles d'infÃ©rence sera prÃ©sentÃ© Ã  la page suivante. \\
  Une premiÃ¨re maniÃ¨re de noter cette rÃ¨gle d'infÃ©rence serait de faire usage de la notation que nous avons vue plus haut. \\[0.5cm]
    1. A (De cet ensemble, nous savons A) \\
    2. $A \imply B$ (De cet ensemble, nous savons que $A \imply B$) \\
  \hspace{10cm}\line(1, 0){60} \\
  $\therefore$ B \\[0.5cm]
  Une autre maniÃ¨re serait d'utiliser l'opÃ©rateur $\vDash$ (celui de la {\bf dÃ©duction}), de la maniÃ¨re suivante : $A, A \implies B \vDash B$, nous pourrions mÃªme Ãªtre tentÃ©s d'utiliser la {\bf rÃ¨gle d'addition}, disant que si l'on a $S \vDash B$, alors, on peut rajouter la formule B Ã  S. Et ainsi, notre ensemble S de base pourra Ãªtre rÃ©Ã©crit en $S = {A, A \imply B, B}$
  Et maintenant, comme promis, voici un tableau comprenant toutes les rÃ¨gles d'infÃ©rence qui seront bien pratiques pour travailler avec les ensembles logiques.
  \FloatBarrier
  \begin{adjustwidth}{300pt}{0pt}
    \begin{table}[H]
    \begin{tabular}{|c|M{5.0cm}|p{5.0cm}|}
      \hline RÃ¨gle d'infÃ©rence & Tautologie & Nom de la rÃ¨gle d'infÃ©rence \\
      \hline $A, B \vDash A \land B$ & $A \land B \imply A \land B$& Loi de combinaison \\
      \hline $A, B \vDash A$ & $(A \land B) \imply A $& Loi de la simplification \\
      \hline $A, A \imply B \vDash B$ & $A \land (A \imply B) \imply B $ & Modus Ponens \\
      \hline $\neg B, A \imply B \vDash \neg A$ & $\neg B \land (A \imply B) \imply \neg A$ & Modus Tollens \\
      \hline $A \imply B, B \imply C \vDash A \imply C$ & $(A \imply B) \land (B \imply C) \imply (A \imply C)$ & Syllogisme hypothÃ©tique \\
      \hline $A \lor B, \neg A \vDash A$ & $(A \lor B) \land \neg A \imply B$ & Syllogisme disjonctif \\
      \hline $A \imply B \vDash A \imply (A \land B)$ & $(A \imply B) \imply (A \imply (A \land B)$ & RÃ¨gle d'absorption \\
      \hline $A \imply B, C \imply B, A \lor C \vDash B$ & $(A \imply B) \land (C \imply B) \land (A \lor C) \imply B$ & Elimination disjonctive\\
      \hline $A, \neg A \vDash B$ & $A \land \neg A \imply B$ & Principe d'explosion \\
      \hline
    \end{tabular}
  \end{table}
\end{adjustwidth}
\FloatBarrier
Le lecteur pourra s'exercer Ã  dÃ©montrer la validitÃ© des tautologies prÃ©sentÃ©es dans le tableau-ci dessus en tant qu'exercice. \\
\subsubsection{Le besoin d'algorithme, prÃ©sentation de l'algorithme de Quine.}

Un ensemble de formules, tout comme une formule peut-Ãªtre inconsistant, cela signifie que notre ensemble est Ã©quivalent Ã  F,et comme nous l'avons vu dans le tableau ci-dessus, on peut dÃ©duire absolument n'importe quoi d'un ensemble inconsistant.\\

Le problÃ¨me des tableaux de vÃ©ritÃ©s, c'est qu'ils prennent de la place, et mÃªme, beaucoup de place. C'est pour cela qu'est venu la nÃ©cessitÃ© de crÃ©er des algorithmes de rÃ©solution d'ensembles de formules, afin de faciliter le travail des logiciens, et ainsi, de rÃ©duire le temps de calcul nÃ©cessaire Ã  un ordinateur. \\

L'algorithme de Quine se dÃ©roule en plusieurs Ã©tapes, tout d'abord, nous allons simplifier, si possibles, les formules logiques contenues dans notre ensemble de formules, par exemple, au lieu d'Ã©crire $A \lor V$, nous pourrons Ã©crire simplement $ V $, et ainsi, supprimer ce $V$ de notre ensemble, comme $B, V \models B$, il y a bien d'autres simplifications possibles, nous laisserons au lecteur le soin d'en trouver.\\

Une fois cette premiÃ¨re Ã©tape passÃ©e, il suffit d'utiliser un arbre logique (ou Ã©ventuellement une table de vÃ©ritÃ©) et enfin, nous avons pu prouver des formules logiques avec l'aide de l'agorithme de Quine.
\subsection{Une logique? Des logiques!}
Les logiciens, non-contents de la seule logique propositionnelle, ont crÃ©Ã©e un trÃ¨s grand nombre de logique, j'en liste quelques une ci-dessous.
\begin{itemize}
  \item La logique linÃ©aire, crÃ©Ã©e par un franÃ§ais, elle est basÃ©e sur la gestion de ressources, c'est une des nombreuses logiques n'excluant pas le tiers exclus, en effet, en logique linÃ©aire, $A \lor \neg A \nvDash V$, cela est simplement du au fait que nous ``utilisons'' la ressource A une fois, elle n'existe donc plus rÃ©ellement, et donc $\neg A$ n'existe pas comme A est devenu indÃ©terminÃ©.
  \item La logique floue, dans laquelle une proposition est vraie selon un certain degrÃ© de probabilitÃ©.
  \item La logique de premier ordre, ou logique des prÃ©dicats, cette logique sera abordÃ©e dans le chapÃ®tre sur Prolog.
  \item La logique boolÃ©enne, elle est basÃ©e sur les portes logiques, les circuits logiques, et les ensembles.
  \item La logique combinatoire, logique inventÃ©e pour formaliser la notion de fonction, et pour limiter le nombre d'opÃ©rateurs nÃ©cessaires pour dÃ©finir le calcul des prÃ©dicats.
  \item La logique modale, ayant recours Ã  des opÃ©rateurs comme ``il est nÃ©cessaire que'' ou ``il est possible que''.
  \item Et bien d'autres...
\end{itemize}
\vfill
\subsection{Introduction Ã  Prolog et Ã  la logique des PrÃ©dicats.}
Dans cette nouvelle sous-section, nous allons nous intÃ©resser Ã  la logique des prÃ©dicats, connue Ã©galement sous le nom de logique de premier ordre. \\
Tout d'abord, en logique des prÃ©dicats, nous aurons besoin de deux nouveaux {\bf quantificateurs}. \\
Ceux-ci sont le quantificateur {\bf universel}, notÃ© $\forall$ [lisez ``pour tout''], et le quantificateur {\bf existentiel}, notÃ© $\exists$ [lisez ``il existe'']. \\
A ces deux quantificateurs viennent s'ajouter:
\begin{itemize}
  \item Des {\bf connecteurs logiques}, qui ont Ã©tÃ© discutÃ©s dans la section prÃ©cÃ©dente.
  \item Des {\bf constantes}, celles-ci reprÃ©sentent un Ã©vÃ©nement, une personne ou un objet en particulier, nous noterons ces constantes avec une majuscule comme premiÃ¨re lettre et un nombre Ã  la fin, par exemple ``Turing\_1'' ou encore ``Chaise\_2''.
  \item Des {\bf variables}, celles-ci reprÃ©sentent un concept gÃ©nÃ©ral ou un ensemble, par exemple, l'ensemble des mathÃ©maticiens, ou encore l'ensemble des chaises dans le monde. Nous noterons ces variables en minuscules, par exemple ``mathÃ©maticiens'' ou encore ``chaise''.
  \item Des {\bf prÃ©dicats}, ceux-ci nous permettent d'Ã©tablir des liens entre nos diffÃ©rentes variables et constantes, nous noterons nos prÃ©dicats avec une majuscule en premiÃ¨re lettre, par exemple ``{\bf Mortel}(x)'' ou encore ``{\bf Humain}(x)''.
  \item Des {\bf fonctions}, qui ont pour but de retourner une valeur, pouvant-Ãªtre autre chose que vrai ou faux. Nous noterons celles-ci en toutes minuscules.
\end{itemize}
\subsubsection{Exemples.}
Pour se faire une bonne idÃ©e, voici quelques phrases franÃ§aises ``traduites'' en logique des prÃ©dicats. \\[0.5cm]
1. Tout les mathÃ©maticiens sont cools. \\
=$>$ $\forall$x ({\bf MathÃ©maticien}(x) $\imply$ {\bf Cool}(x)). \\[0.2cm]
2. Alan Turing et Alonzo Church sont des mathÃ©maticiens. \\
=$>$ {\bf MathÃ©maticien}(Turing\_1) $\land$ {\bf MathÃ©maticien}(Church\_1). \\[0.2cm]
3. Il y a des chats qui ne sont pas noirs. \\
=$>$ $\exists$x ({\bf Chat}(x) $\land$ $\neg${\bf Noir}(x)). \\[0.2cm]

\subsubsection{Qu'est-ce que PROLOG?}
Cette petite introduction passÃ©e, concentrons-nous maintenant sur le coeur du sujet: PROLOG! \\

Prolog a Ã©tÃ© inventÃ© en 1972 par les informaticiens franÃ§ais Alain Colmerauer et Philippe Roussel. \\
C'est un langage de programmation {\bf logique} et son nom est un acronyme pour PROgrammation LOGique. \\
Prolog a Ã©tÃ© trÃ¨s utilisÃ© en Europe et au Japon dans le domaine de l'Intelligence Artificielle, tout en Ã©tant basÃ© sur la logique propositionnelle dont nous avons posÃ© les bases juste au dessus. \\
Il existe de nombreuses distributions de PROLOG\footnote{https://en.wikipedia.org/wiki/Comparison\_of\_Prolog\_implementations}, nous utiliserons ici SWI-PROLOG, avant tout pour son cÃ´tÃ© open-source et gratuit.
\subsubsection{Introduction Ã  la syntaxe de Prolog}
En Prolog, contrairement aux rÃ¨gles que nous avions Ã©tablies en logique des prÃ©dicats, les constantes (ici appelÃ©s Atomes) doivent commencer par une minuscule. Les variables commencent par une majucule. A cela viennent s'ajouter les listes, dÃ©notÃ©es par des []. \\

\underline{{\bf Faits et RÃ¨gles.}} \\[0.2cm]
En PROLOG, un fait s'Ã©crit simplement \\[0.2cm]

Un fait n'a pas de ``corps'', et tiendra toujours. Dans ce cas-ci, cela veut dire que Turing est un mathÃ©maticien, quoiqu'il arrive ce {\bf fait} ne changera pas. \\

Maintenant, si nous essayons de reformuler l'exemple nÂ°1 de notre derniÃ¨re section, ``tous les mathÃ©maticiens sont cools'' en Prolog, cela donne ceci : \\[0.2cm]

On remarque tout de suite que cela est plutÃ´t facile Ã  lire, de plus, si nous ouvrons notre interprÃ¨te Prolog, voilÃ  ce que nous obtenons: \\[0.2cm]

Tout cela est trÃ¨s bien, mais, si j'essaye de demander Ã  prolog si alonzo\_church est cool, que se passe-t-il? \\[0.2cm]
Pas grand chose comme nous le constatons, PROLOG prÃ©fÃ¨re Ã©viter de faire la moindre assomption, et rÃ©pondra ``Faux'' dÃ¨s qu'il ne sait pas. \\

Ensuite, Prolog nous permet de faire de l'arithmÃ©tique, regardons un peu cela, avec une fonction dont le seul rÃ´le est d'additionner deux nombres: \\[0.2cm]
Ouvrons maintenant l'interprÃ¨te et regardons la magie opÃ©rer: \\[0.2cm]

Mais, si pour une obscure raison, je dÃ©cidais de vouloir avoir B, juste en entrant A et C, comment faire? Regardons d'abord comment notre premiÃ¨re version rÃ©agirait Ã  cela: \\[0.2cm]

Heureusement pour nous, Prolog possÃ¨de un module basÃ© sur la logique par contraintes, pour l'utiliser, il suffit d'ajouter\footnote{https://www.swi-prolog.org/man/clpfd.html} \\[0.2cm]

au dessus de votre fichier Prolog, maintenant, modifions lÃ©gÃ¨rement notre prÃ©dicat \\[0.2cm]
Et voilÃ ! Essayons lÃ  maintenant avec notre interprÃ¨te: \\[0.2cm]

\subsubsection{Mon arbre familial, avec Prolog!}
\lstinputlisting[language=Prolog]{genealogia.prolog}
% L'exemple sera mis juste aprÃ¨s.
\newpage
\section{L'approche algorithmique.}
\subsection{Qu'est-ce qu'un algorithme?}
\begin{center}
  \framebox{Un algorithme est une suite d'instructions permettant de rÃ©soudre un problÃ¨me.}
\end{center}

Il faut savoir que nous utilisons des algorithmes bien plus souvent que ce que l'on pourrait croire. Par exemple, quand vous prÃ©parez un gÃ¢teau pour cÃ©lÃ©brer une quelconque occasion, vous aurez besoin d'une recette. Cette recette n'est autre que l'algorithme aidant Ã  la prÃ©paration du gÃ¢teau, chaque Ã©tape de la recette n'Ã©tant qu'une instruction faisant partie de l'algorithme. \\[0.2cm]
Un des tout premiers exemples d'algorithmes est ``l'agorithme d'Euclide'', celui-ci permettait de trouver le PGCD de deux nombres. \\
Voici comment celui-ci fonctionne: \\[0.2cm]
\begin{itemize}
  \item Tout d'abord, nous prenons deux nombres a et b.
  \item Si b = 0 alors, nous retournons a comme Ã©tant le pgcd.
  \item Sinon, nous Ã©crivons que {\bf pgcd}(a, b) = {\bf pgcd}(b, a {\bf mod} b)\\[0.2cm]
\end{itemize}
Et en voici sa traduction en Common Lisp, le langage de programmation que nous utiliserons dans cette partie du dossier.
\lstinputlisting[language=Lisp]{gcd.lisp}

\subsubsection{La complexitÃ© des algorithmes}
Evidemment, tout les algorithmes ne se valent pas, certains sont bien plus lents que d'autres, et ce, pour une seule et mÃªme tÃ¢che.\\
Pour juger de la {\bf complexitÃ©} d'un algorithme, nous utilisons la notation de Landau (dite du ``Big-O'' en anglais). \\
Cette notation a pour but d'estimer l'Ã©volution du nombre d'opÃ©rations qui seront effectuÃ©es par l'algorithme au cours du temps. Car au plus l'algorithme effectue d'opÃ©rations, au plus il sera couteux en temps, ce qui n'est pas pour nous arranger. \\[0.5cm]
Pour montrer l'importance d'avoir des algorithmes performants, nous avons implÃ©mentÃ©s en Lisp deux algorithmes de tris diffÃ©rents: \\[0.2cm]
\begin{itemize}
  \item Le {\bf tri Ã  bulles} de complexitÃ© {\bf $O(n^{2})$}
  \item Le {\bf tri par fusion} de complexitÃ© {\bf $O(n\log{n})$}\\
\end{itemize}
Le {\bf tri Ã  bulles} fonctionne de la maniÃ¨re suivante:
\begin{itemize}
  \item Prendre les deux premiers Ã©lÃ©ments de la liste.
  \item Si le premier est plus grand que le second, les Ã©changer, sinon, les laisser en place.
  \item Faire de mÃªme jusqu'Ã  la fin de la liste.
  \item Une fois arrivÃ© Ã  la fin de la liste, reprendre Ã  partir du dÃ©but de la liste.
  \item Continuer ce procÃ©dÃ© jusqu'Ã  ce que la liste soit parfaitement rangÃ©e.\\[0.2cm]
\end{itemize}
Il est implÃ©mentÃ© de la maniÃ¨re suivante en Common Lisp: \\[0.2cm]
\lstinputlisting[language=Lisp]{bubble_sort.lisp}
Le {\bf tri par fusion} marche de maniÃ¨re assez diffÃ©rente:
\begin{itemize}
  \item Si le tableau n'a qu'un seul Ã©lÃ©ment, il est considÃ©rÃ© comme dÃ©jÃ  triÃ©.
  \item Si il a plus d'un Ã©lÃ©ment, sÃ©parer le tableau en deux parties Ã  peu prÃ¨s Ã©gales.
  \item Trier les deux parties ainsi sÃ©parÃ©es.
  \item Fusionner les deux tableaux triÃ©s en un seul tableau triÃ©. \\[0.2cm]
\end{itemize}
La fonction merge Ã©tant prÃ©dÃ©finie en common Lisp, nous implÃ©menterons notre tri par fusion ainsi.
\lstinputlisting[language=Lisp]{merge_sort.lisp}
Passons maintenant aux {\bf tests de performances}. \\
Afin de mesurer le temps pris par chacun de mes deux algorithmes, j'ai utilisÃ© ``time'', une macro bien pratique pour ce genre de tests. J'utilise le compilateur SBCL pour faire mes tests. En plus de cela, dans un soucis de facilitÃ©, j'utilise la macro random-sample, crÃ©Ã©e par mes soins, me permettant de crÃ©er une liste contenant des nombres alÃ©atoires, de taille fixÃ©e. \\
\begin{lstlisting}[language=Lisp]
;;; Ma macro random-sample bien pratique.
(defmacro random-sample (x)
   (loop for _ below ,x collect (random 1000)))
\end{lstlisting}
Sans plus attendre, voici le tableau montrant les rÃ©sultats de notre petite expÃ©rience.
\begin{table}[H]
  \begin{tabular}{|c|c|c|}
    \hline {\bf Nombre d'Ã©lÃ©ments Ã  triers.} & {\bf Temps Tri Ã  Bulles.} & {\bf Temps Tri par fusion.} \\
    \hline 10 & 0.0000008 secondes & 0.000016 secondes \\
    100 & 0.000089 secondes & 0.000140 secondes \\
    1000 & 0.007863 secondes & 0.001188 secondes \\
    10,000 & 0.318904 secondes & 0.012558 secondes \\
    100,000 & 31.164620 secondes & 0.090092 secondes \\
    \hline
  \end{tabular}
\end{table} \smallskip
Pour des raisons pratiques, je n'ai pas pu obtenir les rÃ©sultats du Tri Ã  Bulles pour le million d'Ã©lÃ©ments. \\
Comme nous pouvons le constater sur le tableau prÃ©cÃ©dent, la complexitÃ© d'un algorithme (estimÃ© par le Big-O) ne mesure pas le temps exact que l'algorithme prendra afin de trier une certaine liste, il s'agit simplement d'un indicateur, montrant comment Ã©voluera le nombre de comparaisons au cours du temps, cet indicateur devenant extrÃªmement siginificatif quand n devient trÃ¨s grand. \\[0.5cm]
\subsection{PrÃ©sentation de structures de donnÃ©es de base}
Pour produire une intelligence artificielle efficace, il nous faut de bons algorithmes, mais il nous faut Ã©galement les structures de donnÃ©es adÃ©quates. \\
Tout d'abord, qu'est-ce qu'une structure de donnÃ©es?
D'aprÃ¨s Wikipedia\footnote{https://fr.wikipedia.org/wiki/Structure\_de\_donn\%C3\%A9es}, une structure de donnÃ©es est une maniÃ¨re d'organiser les donnÃ©es, pour les traiter plus facilement. \\
On conclut donc que le choix judicieux d'une structure de donnÃ©es est indispensable Ã  l'optimisation de la performance de notre IA.

Je prÃ©sente ici trois structures de donnÃ©es de base.
\begin{enumerate}
  \item Les listes simplement chaÃ®nÃ©es.
  \item Les tableaux (ou arrays en anglais.)
  \item Les tables de hachages (ou les dictionnaires.) \\[0.2cm]
\end{enumerate}

\subsubsection{Les listes simplement chaÃ®nÃ©es.}
Une {\bf liste simplement chaÃ®nÃ©e} est une structure de donnÃ©es pouvant contenir plusieurs Ã©lÃ©ments. Chaque Ã©lÃ©ment appartenant Ã  la liste chaÃ®nÃ©e contient deux choses:
\begin{enumerate}
  \item La valeur de l'Ã©lÃ©ment.
  \item Un pointeur pointant vers l'Ã©lÃ©ment suivant. \\[0.2cm]
\end{enumerate}

Ainsi, nous pouvons reprÃ©senter une liste simplement chaÃ®nÃ©e de la maniÃ¨re suivante \\[0.5cm]

% TODO: INSÃ‰RER IMAGE LISTE SIMPLEMENT CHAINÃ‰E.
En Lisp, une liste simplement chaÃ®nÃ©e peut Ãªtre crÃ©e de la maniÃ¨re suivante. \\[0.2cm]
\begin{lstlisting}[language=Lisp]
(defparameter *my-linked-list* '(1 2 3 4 5))
\end{lstlisting}
Ainsi, si nous reprenions le dessin que nous avions utilisÃ© ci-dessus,
*my-linked-list* ressemblera donc Ã  ceci: \\[0.5cm]

% TODO: INSERER IMAGE *MY-LINKED-LIST*

D'ailleurs, pour pouvoir travailler avec des listes chaÃ®nÃ©es, deux opÃ©rateurs bien pratiques s'offrent Ã  nous: ``car'' et ``cdr''. \\[0.2cm]
\begin{lstlisting}[language=LISP]
CL-USER> (car *my-linked-list*)
1
CL-USER> (cdr *my-linked-list*)
(2 3 4 5)
\end{lstlisting}
Nous pouvons Ã©galement chaÃ®ner nos opÃ©rateurs ``car'' et ``cdr'', afin de nous assurer un contrÃ´le total sur notre liste simplement chaÃ®nÃ©e.
\begin{lstlisting}[language=LISP]
CL-USER> (car (cdr *my-linked-list*))
2
CL-USER> (cadr *my-linked-list*) ; Il existe aussi une maniÃ¨re abrÃ©gÃ©e.
2
\end{lstlisting}
Il existe Ã©galement la fonction ``nth'', permettant de rÃ©cupÃ©rer le n-iÃ¨me Ã©lÃ©ment d'une liste chaÃ®nÃ©e. (Il ne faut pas oublier que l'indexing marche comme pour les tableaux, et commence Ã  0.)
\begin{lstlisting}[language=LISP]
CL-USER> (nth 2 *my-linked-list*)
3
\end{lstlisting}

\subsubsection{Les tableaux.}
Le tableau est une structure extrÃªmement importante en programmation,
celle-ci nous permet de stocker un nombre fixe de donnÃ©es, et nous permet d'accÃ©der Ã  ces donnÃ©es de maniÃ¨re rapide. Chaque Ã©lÃ©ment du tableau se retrouve collÃ© en mÃ©moire aux Ã©lÃ©ments qui lui sont adjacent, ainsi, pas besoin de traverser chaque Ã©lÃ©ment du tableau lorsque l'on dÃ©sire accÃ©der au n-iÃ¨me Ã©lÃ©ment du tableau. \\[0.2cm]
Voici comment crÃ©er un tableau en Lisp:
\begin{lstlisting}[language=Lisp]
  CL-USER> (defparameter *my-array* #(1 2 3 4 5))
\end{lstlisting}
Il existe Ã©galement une maniÃ¨re alternative:
\begin{lstlisting}[language=Lisp]
  CL-USER> (defparameter *my-array* (make-array 5 :initial-contents '(1 2 3 4 5)))
\end{lstlisting}
Pour rÃ©cupÃ©rer le n-iÃ¨me Ã©lÃ©ment d'un tableau, il nous suffit de faire:
\begin{lstlisting}[language=Lisp]
  CL-USER> (aref *my-array* 2)
  3
\end{lstlisting}
\subsubsection{Tableaux vs Listes simplement chaÃ®nÃ©es.}
Pour en conclure avec ces deux structures de donnÃ©es, je me propose de faire un petit tableau comparatif final, afin que le lecteur puisse mieux comprendre les diffÃ©rennces entre Tableau, et Liste simplement chaÃ®nÃ©e, (que je noterai SLL pour Single-linked list).
\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline & Tableaux & SLL \\
    \hline {\bf Accession} & O(1) & O(n) \\
    \hline {\bf Insertion} & O(n) & O(1) \\
    \hline {\bf DÃ©lÃ©tion}  & O(n) & O(1) \\
    \hline
  \end{tabular}
\end{table} \smallskip
Comme on le constate sur ce tableau, les arrays ont un rÃ©el avantage lorsque nous dÃ©sirons uniquement lire un Ã©lÃ©ment de notre structure de donnÃ©es, toutefois, si nous dÃ©sirons modifier la structure de donnÃ©es en elle-mÃªme, alors, tout devient plus problÃ©matique, et cela, car notre tableau devra retrouver un autre emplacement libre pour s'y mettre en mÃ©moire. \\
La liste chaÃ®nÃ©e quant Ã  elle, n'a pas besoin de se repositionner entiÃ¨rement lorsqu'on lui ajoute ou qu'on lui retire un Ã©lÃ©ment, il lui suffit plutÃ´t de rajouter un pointeur vers le nouvel Ã©lÃ©ment, ce qui se fait en temps constant (O(1)), peu importe la taille de la liste. Toutefois, la liste chaÃ®nÃ©e a pour inconvÃ©nient d'Ãªtre en croissance linÃ©aire lors de la recherche d'un Ã©lÃ©ment dans la liste, en effet, lors de la recherche d'un Ã©lÃ©ment dans une liste chaÃ®nÃ©e, le programme devra d'abord passer par tout les Ã©lÃ©ments se trouvant avant celui que l'on cherche. \\
Pour dÃ©montrer l'importance d'utiliser la bonne structure au bon endroit, nous allons reprendre notre bon tri Ã  bulles. \\
Pour ceux qui en avaient oubliÃ© l'implÃ©mentation sur les tableaux, la voici:
\lstinputlisting[language=Lisp]{bubble_sort.lisp}
Le lecteur attentif remarquera l'utilisation dans ce code de ``make-array'' et de ``aref'', tout deux synonymes de l'utilisation d'un tableau. Maintenant, transformons cette implÃ©mentation en une implÃ©mentation utilisant des listes simplement chaÃ®nÃ©es. \\
Et maintenant, voici le mÃªme algorithme, mais, sur les listes simplement chaÃ®nÃ©es cette fois-ci.
\lstinputlisting[language=Lisp]{bad_bubble_sort.lisp}
Et maintenant, comparons leurs temps respectifs sur des listes de tailles diffÃ©rentes avec l'aide d'un nouveau tableau, (mon mode opÃ©ratoire reste le mÃªme, j'utilise SBCL, et la macro time, pour crÃ©er une liste contenant des nombres alÃ©atoires, j'utilise toujours ma macro random-sample.)
\begin{table}[H]
  \begin{tabular}{|c|c|c|}
    \hline & Tri Ã  bulles (Tableaux) & Tri Ã  bulles (SLL) \\
    \hline 10 &  0.0000008 secondes &  0.000009 secondes \\
    \hline 100 &  0.000089 secondes &  0.002111 secondes \\
    \hline 1000 & 0.007863 secondes &  0.750918 secondes \\
    \hline 10000 & 0.318904 secondes & 888.190640 secondes \\
    \hline 100000 &  31.164620 secondes & $>$1000 secondes \\
    \hline
  \end{tabular}
\end{table}
La diffÃ©rence de performance entre nos deux implÃ©mentations du mÃªme algorithme est Ã©norme, et pourtant, nous n'avons pas changÃ© l'algorithme en lui-mÃªme! J'espÃ¨re que notre petite expÃ©rience montre bien au lecteur l'importance d'un choix de structure de donnÃ©es adÃ©quat.
\subsubsection{Les tables de hachages.}
Une table de hachage (ou un dictionnaire en python) est une des structures de donnÃ©es les plus utiles en ce qui concerne l'optimisation d'algorithmes. \\
Son utilisation est simple; avec une table de hachage, nous relions des clÃ©s avec des valeurs. \\ Ainsi, si dans une table de hachage, je relie le mot ``bonjour'' avec le mot ``hello'', mon mot ``bonjour'' sera considÃ©rÃ© comme Ã©tant la clÃ©, et le mot ``hello'' comme Ã©tant la valeur. \\
En Lisp, pour crÃ©er une telle table de hachage, il faut faire: \\
\begin{lstlisting}[language=Lisp]
CL-USER> (defparameter *my-dict* (make-hash-table))
*MY-DICT*
CL-USER> (setf (gethash 'bonjour *my-dict*) 'hello)
HELLO
CL-USER> (gethash 'bonjour *my-dict*)
HELLO
\end{lstlisting}
Ce procÃ©dÃ© Ã©tant toutefois un peu fastidieux, nous utiliserons ici la bibliothÃ¨que lisp connue sous le nom de serapeum. \\
\begin{lstlisting}[language=Lisp]
CL-USER> (ql:quickload :serapeum) ;; Ici, nous dÃ©clarons la bibliothÃ¨que.
To load "serapeum":
  Load 1 ASDF system:
    serapeum
; Loading "serapeum"
.
Switching to the BALLAND2006 optimizer

(:SERAPEUM)
CL-USER> (defparameter *my-dict* (serapeum:dict 'bonjour 'hello))
*MY-DICT*
CL-USER> (gethash 'bonjour *my-dict*)
HELLO
\end{lstlisting}
Pour montrer un cas pratique d'utilisation de tables de hachages, nous allons crÃ©er un mini-programme qui permet de convertir des phrases en morse. \\
Ce programme se fait en deux parties, tout d'abord, nous dÃ©finissons une table de hachage qui nous remet la traduction morse de chaque lettre et de chaque chiffre. \\
\begin{lstlisting}[language=Lisp]
(ql:quickload :serapeum)

(defparameter *latin->morse*
  (serapeum:dict #\a "._" #\b "_..." #\c "_._." #\d "_.."
                 #\e "." #\f ".._." #\g "__." #\h "...."
                 #\i ".." #\j ".___" #\k "_._" #\l "._.."
                 #\m "__" #\n "_." #\o "___" #\p ".__."
                 #\q "__._" #\r "._." #\s "..." #\t "_"
                 #\u ".._" #\v "..._" #\w ".__" #\x "_.._"
                 #\y "_.__" #\z "__.." #\1 ".____" #\2 "..___"
                 #\3 "...__" #\4 "...._" #\5 "....." #\6 "_...."
                 #\7 "__..." #\8 "___.." #\9 "____." #\0 "_____"
                 #\SPACE " "))
\end{lstlisting}
Voici notre dictionnaire! Ne soyez pas surpris par les ``\#\'', c'est ainsi que nous dÃ©finissons des charactÃ¨res en common lisp. \\
Maintenant, la deuxiÃ¨me partie consistera simplement Ã  crÃ©er une fonction chargÃ©e de transformer nos phrases vers du morse. \\
\begin{lstlisting}[language=Lisp]
(defun convert-to-morse (sentence)
  "Cette fonction s'occupe de convertir
nos phrases vers du code Morse, grÃ¢ce au dictionnaire
crÃ©Ã© ci-dessus!"
  (let ((converted-list
          (loop for letter across sentence
                collect (gethash letter *latin->morse*))))
  (format nil "~{~A~}" converted-list)))
\end{lstlisting}
Il ne nous reste plus qu'Ã  tester.
\begin{lstlisting}[language=Lisp]
CL-USER> (convert-to-morse "ceci est une phrase")
"_._.._._... ...._ ..__.. .__......_.._...."
\end{lstlisting}
Et voilÃ  comment notre programme marche! \\
Petite parenthÃ¨se au niveau de la complexitÃ© de notre fonction ``convert to morse''. Tout d'abord, il faut savoir que pour chercher une valeur avec une clÃ© dans un dictionnaire, la complexitÃ© temporelle est de O(1)! Peu importe la taille du dictionnaire, cela prendra toujours aussi peu de temps de chercher une clef dedans, c'est la raison pour laquelle ceux-ci sont trÃ¨s utilisÃ© de nos jours.
Pour les lecteurs intÃ©ressÃ©s, nous conseillons fortement de vous renseigner sur la fonction SHA, c'est grÃ¢ce Ã  cette fonction de hachage que les dictionnaires marchent aussi bien. \\
Ainsi, pour en revenir Ã  notre programme, nous appliquons une opÃ©ration de complexitÃ© O(1) sur chaque Ã©lÃ©ment de notre liste, soit, n fois. On peut donc en dÃ©duire que notre fonction ``convert-to-morse'' est donc de complexitÃ© O(n), car nous appliquons n fois une opÃ©ration de complexitÃ© O(1). \\[0.2cm]
\subsubsection{Promenons-nous dans les bois.}
Pour comprendre l'intÃ©rÃªt des arbres dichotomiques en programmation, intÃ©ressons nous Ã  un petit problÃ¨me assez simple. \\
Imaginez que je pense Ã  un nombre, compris entre 1 et 1000, et que vous deviez deviner ce nombre avec le moins d'essais possibles, Ã  la mÃªme maniÃ¨re que dans le jeu du ``Juste Prix'', je vous dirai si votre essai est trop grand, ou trop petit. \\
La premiÃ¨re stratÃ©gie Ã©vidente, serait de commencer par 1, puis ensuite, si mon nombre n'est pas 1, essayer avec 2, puis ensuite, essayer avec 3, et ceci, jusqu'Ã  ce que vous trouviez le nombre auquel je pense. \\
Cette premiÃ¨re stratÃ©gie pourrait faire penser Ã  la maniÃ¨re Ã  laquelle il faut chercher un Ã©lÃ©ment dans une liste simplement chaÃ®nÃ©e, en effet, si je pense au nombre 629, il va falloir passer par les 628-iÃ¨mes Ã©lÃ©ments se trouvant avant. Dans ce cas-ci, comme pour lire un Ã©lÃ©ment dans une liste simplement chaÃ®nÃ©e, nous dirons que la complexitÃ© de cet algorithme sera de O(n). \\
Une deuxiÃ¨me maniÃ¨re de faire serait de faire ce que l'on appelle une recherche dite ``par dichotomie''. Tout d'abord, prenons un nombre au milieu entre 1 et 1000, ici, ce sera 500, si je dis ``au dessus'', alors, il suffira de prendre le milieu entre 500 et 1000, ici, ce sera 750, dÃ©sormais, si je dis ``en dessous'', il faudra alors faire $\frac{500 + 750}{2} = 625$, ainsi, en appliquant cet algorithme jusqu'au bout, vous trouverez le nombre auquel je pense en utilisant un algorithme de complexitÃ© O(log n)! \\ Ainsi, vous trouverez grÃ¢ce Ã  cette technique le nombre auquel je pense en maximum $\log_{2}{n}$ essais (oÃ¹ n est le nombre maximum, qui est ici 1000). \\
J'espÃ¨re que cette petite explication aura pu expliquer au lecteur le fonctionnement d'une recherche par dichotomie. Maintenant, pour ce qui est de l'implÃ©mentation d'une telle recherche en Lisp: \\
\lstinputlisting[language=Lisp]{dichotomia.lisp}
Plus qu'Ã  la tester!
\begin{lstlisting}[language=Lisp]
[1] CL-USER> (binary-search 1 1000)
500?
plus-haut
750?
plus-bas
625?
plus-haut
687?
plus-bas
656?
plus-bas
640?
plus-bas
632?
plus-bas
628?
plus-haut
630?
plus-bas
629?
oui
Ton nombre a Ã©tÃ© trouvÃ© en 9 essais
\end{lstlisting}

Cette petite introduction Ã  la recherche par dichtomie servait surtout Ã  donner une intuition au lecteur de l'importance des arbres binaires. \\
Ceux-ci fonctionnent d'une maniÃ¨re similaire Ã  notre recherche dichotomique. \\
Sur un arbre binaire, chaque noeud est soit reliÃ© Ã  rien (ou ``nil''), soit reliÃ© Ã  sa ``gauche'' Ã  un noeud contenant une valeur plus petite que celle de son noeud parent, soit reliÃ© Ã  sa ``droite'' Ã  un noeud contenant une valeur plus grande que celle de son noeud parent. Nous pouvons donc reprÃ©senter un arbre binaire ainsi: \\[0.2cm]

\subsection{Qu'est-ce que Lisp?}
Lisp est une famille de langages de programmation fonctionnels, inventÃ©s en 1958 par John McCarthy (l'homme ayant inventÃ© le terme ``intelligence artificielle''). \\
Ceux-ci sont reconnaissables facilement grÃ¢ce au trÃ¨s grand nombre de parenthÃ¨ses prÃ©sentes dans chacun des dialectes de Lisp. \\
Aujourd'hui, le dialecte Lisp le plus utilisÃ© reste {\bf Clojure}, toutefois, il en reste d'autres gardant toujours leur cote de popularitÃ©, pour n'en citer que quelques-un, nous avons
\begin{itemize}
  \item {\bf Scheme}, qui est un dialecte trÃ¨s minimaliste de Lisp, trÃ¨s utilisÃ© au niveau acadÃ©mique.
  \item {\bf Emacs Lisp}, un dialecte trÃ¨s pratique pour tout ceux dÃ©sirant configurer l'Ã©diteur de texte Emacs.
  \item {\bf Racket}, un super-set de Scheme.
  \item {\bf Common Lisp} est le dialecte que nous utiliserons ici, ce dialecte a toujours eu la rÃ©putation d'Ãªtre plus orientÃ© vers les applications pratiques, et n'a jamais reÃ§u de grandes faveurs acadÃ©miques. Common Lisp a toutefois le mÃ©rite d'avoir Ã©tÃ© standardisÃ©, de bÃ©nÃ©ficier d'un systÃ¨me orientÃ©-objet connu sous le nom de CLOS.
\end{itemize}
\subsubsection{Les bases de Lisp.}
Tout d'abord, pour commencer notre aventure avec Lisp, ouvrons donc notre REPL (cela peut-Ãªtre SBCL, Clisp, ou encore CCL), et additionnons deux nombres. \\
\begin{lstlisting}[language=Lisp]
CL-USER> (+ 3 5)
8
\end{lstlisting}
Cela peut sembler bien Ã©trange pour le non-initÃ©, et pourtant, tout cela est parfaitement logique. \\
En fait, lorsque l'on dÃ©sire appeler une fonction (comme par exemple ici ``+''), la syntaxe sera toujours ``({\bf fonction} {\bf arguments})''. Prenons quelques autres exemples avec quelques opÃ©rations arithmÃ©tiques. \\
\begin{lstlisting}[language=Lisp]
CL-USER> (- 2 1)
1
CL-USER> (* 3 4 2)
24
CL-USER> (/ 5 6)
5/6
CL-USER> (/ 5 6.0)
0.8333333
\end{lstlisting}
Comme on peut le voir, la logique reste la mÃªme pour tout les opÃ©rateurs, aussi, cette syntaxe nous permet Ã©galement de mettre Ã  ces opÃ©rateurs autant d'arguments que l'on le souhaite, (l'exemple est donnÃ© ci-dessus avec l'opÃ©rateur de multiplication.). \\
Egalement, l'opÃ©ration de division ne remet pas directement un nombre Ã  virgule, mais plutÃ´t un Ratio, si l'on ne lui donne pour argument uniquement des nombres entiers. \\
Pour dÃ©clarer une variable en Lisp, plusieurs choix s'offrent Ã  nous, je prÃ©senterai uniquement ici ``defparameter''.
\begin{lstlisting}[language=Lisp]
CL-USER> (defparameter *test* 'bonjour)
*TEST*
CL-USER> *test*
BONJOUR
\end{lstlisting}
J'en profite pour attirer l'attention sur l'utilisation de ``*'' autour du nom de la variable. Ceux-ci sont appelÃ©s les ``cache-oreilles'', il ne s'agit ici que d'une convention, il est tout Ã  fait acceptable de ne pas utiliser de caches-oreilles lors ed la dÃ©finition d'une variable globale. \\[0.2cm]
Maintenant, j'utiliserai la fin de cette petite introduction comme prÃ©texte pour prÃ©senter ``la rÃ©cursion''. \\
Pour montrer un exemple de fonction rÃ©cursive, je prÃ©senterai ici la fonction factorielle, fonction rÃ©cursive par excellence. \\
Tout d'abord, pour dÃ©clarer une fonction, nous utiliserons le mot-clÃ© {\bf defun}.
\begin{lstlisting}[language=Lisp]
CL-USER> (defun factorial (x) ...)
\end{lstlisting}
Il faut ensuite rÃ©flÃ©chir Ã  ce qu'il faudra mettre au sein de notre fonction. \\
La rÃ©cursion est un processus en 3 Ã©tapes. \\
\begin{enumerate}
  \item Trouver la valeur de f(0) (ou de n'importe quel cas de base.)
  \item Supposer que cette fonction remettra un nombre correct pour f(n-1).
  \item Trouver la valeur de f(n) en fonction de f(n-1).
\end{enumerate}
L'exemple ici est assez simple, et est souvent donnÃ© en introduction Ã  la rÃ©cursion. Voici donc une dÃ©finition formelle de notre fonction factorielle. \\
$$\begin{cases}0! = 1 \\ n! = n \cdot (n - 1)! \end{cases}$$
Ainsi, uniquement grÃ¢ce Ã  cette simple dÃ©finition, nous allons pouvoir coder cette fonction en Common Lisp \\
\begin{lstlisting}[language=Lisp]
CL-USER> (defun factorial (x)
                   (if (= x 0)
                       1
                      (* x (factorial (- x 1)))))
FACTORIAL
\end{lstlisting}
On constate directement la simplicitÃ© et l'Ã©lÃ©gance avec laquelle cette fonction peut-Ãªtre ainsi programmÃ©e. D'autres fonctions peuvent-Ãªtre codÃ©e de maniÃ¨re rÃ©cursive, l'exemple de l'algorithme de tri par fusion, ou encore l'agorithme d'Euclide pour calculer le pgcd sont deux exemples de fonctions rÃ©cursives dont j'ai pu montrer l'implÃ©mentation ci-dessus. \\
Un autre exemple d'algorithme utilisant la rÃ©cursion serait l'algorithme ``quick-sort'' dit du ``tri-rapide'', en voici son implÃ©mentation \\
\lstinputlisting[language=Lisp]{quick_sort.lisp}

Si le lecteur en sent l'envie, nous l'encourageons Ã  essayer de coder la fonction rÃ©cursive d'Ackermann, ou encore la McCarthy 91. \\
\subsubsection{Programme Lisp pour rÃ©soudre parfaitement le jeu de Nim.}
Afin que le lecteur se fasse une idÃ©e de comment utiliser dans des cas plus concrets, nous allons vous prÃ©senter une intelligence artificielle, assez basique, gagnant au jeu de Nim Ã  plusieurs tas. (Aussi connu sous le nom de jeu de Marienbad.), dans ce jeu, plusieurs alumettes sont disposÃ©es sur plusieurs piles, le but du jeu est de rÃ©colter la derniÃ¨re alumette. \\
L'intelligence gagnant Ã  ce genre de jeux est assez basique, en effet, le jeu de Nim Ã  plusieurs tas est un jeu rÃ©solu parfaitement. \\
La stratÃ©gie gagnante pour ce jeu est simple, nous dÃ©finissons une position gagnante une position oÃ¹ la``nim-somme'' (qui est en rÃ©alitÃ© l'opÃ©rateur ``xor'' ou $\oplus$ appliquÃ© Ã  la reprÃ©sentation binaire de notre tas) est diffÃ©rent de 0, et Ã  l'inverse, une position perdante est une position oÃ¹ la ``nim-somme'' appliquÃ©e aux tas est Ã©gale Ã  0. \\
Un exemple de position perdante serait la position oÃ¹ les alumettes seraient rÃ©parties sur 4 tas avec 1 alumette sur le premier tas, 3 sur le deuxiÃ¨me, 5 sur le 3iÃ¨me, et 7 sur le dernier. \\
$$1 \oplus 3 \oplus 5 \oplus 7 = 0$$
Pour se le prouver, on peut utiliser notre interprÃ¨te Lisp et faire
\begin{lstlisting}[language=Lisp]
CL-USER> (logxor 1 3 5 7)
0
\end{lstlisting}
Le but de l'ordinateur sera donc de toujours se trouver en position de sÃ©curitÃ©, et de toujours mettre le joueur en position perdante. \\
Le twist que nous avons apportÃ© est le fait que le joueur peut dÃ©cider des tas avec lesquels ils va jouer, et ainsi, mettre directement l'ordinateur en position de dÃ©faite, notre IA devra donc se montrer capable de jouer des coups, mÃªme en perdant. \\
\lstinputlisting[language=Lisp, linerange={1-2}]{Nim/nim-game-player.lisp}
Ici, je ne fais que dÃ©finir une variable globale *heaps*, celle-ci reprÃ©sentera les tas disponibles au travers de mon programme. \\
\lstinputlisting[language=Lisp, linerange={4-10, 27-32, 61-67}]{Nim/nim-game-player.lisp}
Ces deuc fonctions seront dites des ``fonction d'aide'', elles auront surtout pour utilitÃ© de ne pas devoir surcharger les fonctions principales. \\
Le lecteur attentif remarquera que je termine le nom de ces fonctions par un ``p'', cela est dÃ» au fait que ces fonctions sont des {\bf prÃ©dicats}, elles ne peuvent retourner que ``t'' ou ``nil'' (``vrai'' ou ``faux''), ceci n'Ã©tant Ã©galement qu'une convention, si le lecteur dÃ©sire Ã©crire des prÃ©dicats sans laisser de ``p'' au bout, SBCL ne lui trouvera rien Ã  redire.\\
Aussi, on peut remarquer dans les deux premiÃ¨res fonctions l'utilisation de ``reduce'', il s'agit d'une fonction destinÃ©e aux {\bf catamorphismes}, cela veut dire qu'elles permettent de passer d'une structure de donnÃ©es comme une liste, ou un arbre, vers un scalaire, comme un entier ou encore un flottant. \\
Egalement, j'utilise \#', ce symbole nous permet d'expliciter que nous utilisons une fonction, et pas une variable.\\
\lstinputlisting[language=Lisp, linerange={12-26, 34-48}]{Nim/nim-game-player.lisp}
Nous voici enfin au cÅ“ur du programme. Avec nos fonctions ``play-winning-move'' et ``play-random-legal-move'' sont nos deux fonctions oÃ¹ est contenue notre joueur, les commentaires explicitant dÃ©jÃ  leurs actions, je me concentrerai surtout sur l'implÃ©mentation. \\ Comme nous le remarquons, j'utilise {\bf let} et {\bf loop}, {\bf let} me permet de dÃ©clarer des variables dites ``locales'', cela me permet d'avoir un code propre, oÃ¹ chaque chose reste Ã  sa place. \\ {\bf loop} est une macro, qui permet d'itÃ©rer, ou de rÃ©pÃ©ter un nombre certain de fois une mÃªme action, je l'utilise ici en raison de la lisibilitÃ© de celle-ci, certains prÃ©fÃ¨rent la macro ``do'', je trouve cette derniÃ¨re illisible, mais j'encourage le lecteur  se renseigner sur cette derniÃ¨re si le coeur le lui en dit.\\
\lstinputlisting[language=Lisp, linerange={50-60}]{Nim/nim-game-player.lisp}
Je ne ferai remarquer ici que l'utilisation de la macro {\bf cond}, une autre maniÃ¨re d'Ã©crire des conditions en Lisp.
\lstinputlisting[language=Lisp, linerange={69-95}]{Nim/nim-game-player.lisp}
Cette trÃ¨s longue fonction fait office d'interface utilisateur. Nous avons dÃ©jÃ  fait remarquÃ© au lecteur en commentaires l'utilisation de la rÃ©cursion. \\
Egalement, nous signalons {\bf progn}, une fonction bien pratique pour dÃ©finir des blocs de code.
\lstinputlisting[language=Lisp]{Nim/nim-game-player.lisp}
Nous finissons enfin notre programme avec cette fonction nim-game-repl, permettant de commencer une partie entre humain et ordinateur.
\subsection{Le pathfinding.}
\subsubsection{PrÃ©sentation du problÃ¨me.}
\subsubsection{L'algorithme de Dijkstra.}
\subsubsection{Le besoin d'heuristiques.}
\subsubsection{Dijkstra avec de l'heuristique: A*!}

\subsection{Des programmes et des jeux!}
\subsubsection{L'agorithme Minimax.}
\subsubsection{$\alpha\beta$-Ã©lagage.}
\subsubsection{Du dynamisme bon sang!}
\subsection{Un programme de jeu.}
\newpage
\section{Le Machine Learning.}
\subsection{DÃ©finition du Machine Learning}
Le Machine Learning, ou Apprentissage Automatique, est un type d'intelligence artificielle qui avec les donnÃ©es Ã  analyser et sur lesquelles s'entraÃ®ner permet aux ordinateurs dâ€™apprendre par expÃ©rience sans avoir Ã©tÃ© explicitement programmÃ© Ã  cet effet ou par intervention humaine. Cela consiste en algorithmes dâ€™apprentissage qui amÃ©liorent leur performance Ã  exÃ©cuter des tÃ¢ches au fil du temps grÃ¢ce Ã  de lâ€™expÃ©rience.\\[1.0cm]
\subsection{Les Maths dans le Machine Leanring.}
\begin{enumerate}
  \item De nombreux data scientists (chargÃ©s de la gestion, de lâ€™analyse et de lâ€™exploitation des donnÃ©es au sein dâ€™une entreprise) considÃ¨rent le machine Learning comme un apprentissage statistique.
  \item Matrice et algÃ¨bre matricielle, exemple :
        \begin{enumerate}
          \item Les suggestions dâ€™amis sur Facebook
          \item Recommandation de vidÃ©o sur Facebook
          \item $\cdots$
        \end{enumerate}
  \item Fonction, variable, Ã©quation et graphique, ...
\end{enumerate}

\subsection{Les rÃ©saux de neurones}
Une couche de neurones dâ€™entrÃ©es, plusieurs couches cachÃ©es, une couche de sortie suivie dâ€™une fonction dâ€™activation.
Chaque neurone possÃ¨de une valeur obtenue par une fonction de combinaison Ã©tant la somme des valeurs des neurones de la couche prÃ©cÃ©dente, chacune multipliÃ©e par un poids spÃ©cifique
$ z = x_1 \cdot p_1 + x_2 \cdot p_2 + \cdots + x_n \cdot p_n $ \\
Une fois la (ou les) valeur de la couche de sortie obtenue, on applique Ã  celle-ci une fonction dâ€™activation qui transforme la valeur en fonction dâ€™un seuil. Si en dessous du seuil, inactif (0/-1), aux environs du seuil, phase de transition, et au-dessus du seuil, actif (1/$>$1). Le type de fonction varie dâ€™un cas Ã  lâ€™autre, mais les plus rÃ©currentes sont la fonction sigmoÃ¯de $ \frac{1}{1 + e^{-x}}$ la fonction tangente hyperbolique $ \frac{2} {1 + e^{-2x}} -1 $
ou encore la fonction ReLU $\begin{cases} 0 & x < 0 \\ x & x >= 0 \end{cases}$ \\
Durant lâ€™apprentissage, les poids sont des valeurs prises au hasard. Il faut donc les ajuster pour fournir une rÃ©ponse qui se rapproche au mieux de la rÃ©alitÃ©. Comme on entraÃ®ne notre rÃ©seau, on connaÃ®t la vraie valeur finale. On va donc appliquer une fonction de coÃ»t afin de calculer le gradient dâ€™erreur entre la valeur rÃ©elle et la valeur prÃ©dite $ \frac{1}{2}(y_r - y_p)^2 $, et ainsi mettre Ã  jour les poids par rÃ©tropropagation (! il y a des maths plus compliquÃ©es derriÃ¨re). A chaque nouvelles donnÃ©es injectÃ©es lors de lâ€™apprentissage, le rÃ©seau est plus performant.

\subsection{Intro au langage Python}
\begin{enumerate}
  \item CrÃ©Ã© par Guido van Rossum au Stichting Mathematisch Centrum en Hollande.
  \item Python est le successeur dâ€™un langage de programmation nommÃ© â€œABCâ€
  \item Le nom du langage vient de la sÃ©rie Monty Pythonâ€™s flying Circus dont Guido Van Rossum Ã©tait fan. Cependant lâ€™image du serpent paraissait plus Ã©vidente pour tout le monde, il a donc dÃ©cidÃ© dâ€™utiliser celle-ci comme symbole du langage.
  \item La premiÃ¨re version de Python paraissait en 1991
  \item Câ€™est un langage de programmation open source, câ€™est Ã  dire gratuit et libre dâ€™utilisation
  \item Python au fil des annÃ©es a Ã©tÃ© mis Ã  jour beaucoup de fois et est passÃ© dâ€™une version 1.5 en 1999 jusquâ€™Ã  3.9 cette annÃ©e (2020), nous nous intÃ©resserons surtout aux diffÃ©rences entre python 2 et python 3 qui ont Ã©tÃ© les plus marquantes.
      \begin{enumerate}
          \item \underline{{\bf Python2: }}
              \begin{itemize}
                \item version plus facile que python 1 mais contenant plus dâ€™erreurs.
                      \begin{enumerate}
                        \item erreur de syntaxe, manque de â€˜:â€™, manque dâ€™une lettre, etc (erreur dâ€™analyse de code)
                        \item Nouvelles exceptions, comme ZeroDivisionError(division par zÃ©ro), ValueError(valeur incorrecte), Etc.
                      \end{enumerate}
                \item  Pas difficile Ã  reconvertir vers python 3 mais ce nâ€™est pas fiable
                \item La programmation est plus complexe sur python 2
                \item Le support de la version 2 de python a Ã©tÃ© abandonnÃ© cette annÃ©e, en 2020.
                \item etc (opposition des tirets de python 3)
              \end{itemize}
        \item \underline{{\bf Python3:}}
              \begin{itemize}
                \item syntaxe plus simple et facilement comprÃ©hensible.
                \item  stockage unicode (Ã©change de texte dans diffÃ©rentes langues).
                \item La valeur des variables utilisÃ©es ne change jamais.
                \item Certaines fonctions on Ã©tÃ© remplacÃ© par dâ€™autres (python3; range(), python2; xrange()) range ou xrange servent toutes les 2 a crÃ©er une liste et aussi des itÃ©rations (rÃ©pÃ©titions).
                \item CrÃ©ation de bibliothÃ¨ques qui ne peuvent pas Ãªtre crÃ©Ã©es avec python2.
                      \begin{itemize}
                        \item Python3 est aujourdâ€™hui la version la plus conseillÃ©e surtout pour ceux dÃ©sirant de commencer la programmation
                      \end{itemize}
              \end{itemize}
      \end{enumerate}
\end{enumerate}

\end{document}
